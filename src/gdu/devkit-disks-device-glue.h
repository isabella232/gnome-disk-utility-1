/* Generated by dbus-binding-tool; do not edit! */

#include <glib.h>
#include <dbus/dbus-glib.h>

G_BEGIN_DECLS

#ifndef _DBUS_GLIB_ASYNC_DATA_FREE
#define _DBUS_GLIB_ASYNC_DATA_FREE
static
#ifdef G_HAVE_INLINE
inline
#endif
void
_dbus_glib_async_data_free (gpointer stuff)
{
	g_slice_free (DBusGAsyncData, stuff);
}
#endif

#ifndef DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_DeviceKit_Disks_Device
#define DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_DeviceKit_Disks_Device

static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_job_cancel (DBusGProxy *proxy, GError **error)

{
  return dbus_g_proxy_call (proxy, "JobCancel", error, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_job_cancel_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_job_cancel_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_job_cancel_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_job_cancel_async (DBusGProxy *proxy, org_freedesktop_DeviceKit_Disks_Device_job_cancel_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "JobCancel", org_freedesktop_DeviceKit_Disks_Device_job_cancel_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_partition_table_create (DBusGProxy *proxy, const char * IN_scheme, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "PartitionTableCreate", error, G_TYPE_STRING, IN_scheme, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_partition_table_create_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_partition_table_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_partition_table_create_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_partition_table_create_async (DBusGProxy *proxy, const char * IN_scheme, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_partition_table_create_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "PartitionTableCreate", org_freedesktop_DeviceKit_Disks_Device_partition_table_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_scheme, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_partition_delete (DBusGProxy *proxy, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "PartitionDelete", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_partition_delete_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_partition_delete_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_partition_delete_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_partition_delete_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_partition_delete_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "PartitionDelete", org_freedesktop_DeviceKit_Disks_Device_partition_delete_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_partition_create (DBusGProxy *proxy, const guint64 IN_offset, const guint64 IN_size, const char * IN_type, const char * IN_label, const char ** IN_flags, const char ** IN_options, const char * IN_fstype, const char ** IN_fsoptions, char** OUT_created_device, GError **error)

{
  return dbus_g_proxy_call (proxy, "PartitionCreate", error, G_TYPE_UINT64, IN_offset, G_TYPE_UINT64, IN_size, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_STRV, IN_options, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_fsoptions, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_created_device, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_partition_create_reply) (DBusGProxy *proxy, char *OUT_created_device, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_partition_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  char* OUT_created_device;
  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_created_device, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_partition_create_reply)data->cb) (proxy, OUT_created_device, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_partition_create_async (DBusGProxy *proxy, const guint64 IN_offset, const guint64 IN_size, const char * IN_type, const char * IN_label, const char ** IN_flags, const char ** IN_options, const char * IN_fstype, const char ** IN_fsoptions, org_freedesktop_DeviceKit_Disks_Device_partition_create_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "PartitionCreate", org_freedesktop_DeviceKit_Disks_Device_partition_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT64, IN_offset, G_TYPE_UINT64, IN_size, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_STRV, IN_options, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_fsoptions, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_partition_modify (DBusGProxy *proxy, const char * IN_type, const char * IN_label, const char ** IN_flags, GError **error)

{
  return dbus_g_proxy_call (proxy, "PartitionModify", error, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_partition_modify_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_partition_modify_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_partition_modify_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_partition_modify_async (DBusGProxy *proxy, const char * IN_type, const char * IN_label, const char ** IN_flags, org_freedesktop_DeviceKit_Disks_Device_partition_modify_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "PartitionModify", org_freedesktop_DeviceKit_Disks_Device_partition_modify_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_type, G_TYPE_STRING, IN_label, G_TYPE_STRV, IN_flags, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_filesystem_create (DBusGProxy *proxy, const char * IN_fstype, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "FilesystemCreate", error, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_filesystem_create_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_filesystem_create_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_filesystem_create_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_filesystem_create_async (DBusGProxy *proxy, const char * IN_fstype, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_filesystem_create_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "FilesystemCreate", org_freedesktop_DeviceKit_Disks_Device_filesystem_create_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_fstype, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label (DBusGProxy *proxy, const char * IN_new_label, GError **error)

{
  return dbus_g_proxy_call (proxy, "FilesystemSetLabel", error, G_TYPE_STRING, IN_new_label, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label_async (DBusGProxy *proxy, const char * IN_new_label, org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "FilesystemSetLabel", org_freedesktop_DeviceKit_Disks_Device_filesystem_set_label_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_new_label, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_filesystem_mount (DBusGProxy *proxy, const char * IN_filesystem_type, const char ** IN_options, char ** OUT_mount_path, GError **error)

{
  return dbus_g_proxy_call (proxy, "FilesystemMount", error, G_TYPE_STRING, IN_filesystem_type, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_mount_path, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_filesystem_mount_reply) (DBusGProxy *proxy, char * OUT_mount_path, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_filesystem_mount_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  char * OUT_mount_path;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_mount_path, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_filesystem_mount_reply)data->cb) (proxy, OUT_mount_path, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_filesystem_mount_async (DBusGProxy *proxy, const char * IN_filesystem_type, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_filesystem_mount_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "FilesystemMount", org_freedesktop_DeviceKit_Disks_Device_filesystem_mount_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_filesystem_type, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount (DBusGProxy *proxy, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "FilesystemUnmount", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "FilesystemUnmount", org_freedesktop_DeviceKit_Disks_Device_filesystem_unmount_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_filesystem_check (DBusGProxy *proxy, const char ** IN_options, gboolean* OUT_is_clean, GError **error)

{
  return dbus_g_proxy_call (proxy, "FilesystemCheck", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_BOOLEAN, OUT_is_clean, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_filesystem_check_reply) (DBusGProxy *proxy, gboolean OUT_is_clean, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_filesystem_check_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  gboolean OUT_is_clean;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_BOOLEAN, &OUT_is_clean, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_filesystem_check_reply)data->cb) (proxy, OUT_is_clean, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_filesystem_check_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_filesystem_check_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "FilesystemCheck", org_freedesktop_DeviceKit_Disks_Device_filesystem_check_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files (DBusGProxy *proxy, GPtrArray** OUT_processes, GError **error)

{
  return dbus_g_proxy_call (proxy, "FilesystemListOpenFiles", error, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_INVALID)), OUT_processes, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files_reply) (DBusGProxy *proxy, GPtrArray *OUT_processes, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  GPtrArray* OUT_processes;
  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_INVALID)), &OUT_processes, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files_reply)data->cb) (proxy, OUT_processes, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files_async (DBusGProxy *proxy, org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "FilesystemListOpenFiles", org_freedesktop_DeviceKit_Disks_Device_filesystem_list_open_files_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_luks_unlock (DBusGProxy *proxy, const char * IN_passphrase, const char ** IN_options, char** OUT_cleartext_device, GError **error)

{
  return dbus_g_proxy_call (proxy, "LuksUnlock", error, G_TYPE_STRING, IN_passphrase, G_TYPE_STRV, IN_options, G_TYPE_INVALID, DBUS_TYPE_G_OBJECT_PATH, OUT_cleartext_device, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_luks_unlock_reply) (DBusGProxy *proxy, char *OUT_cleartext_device, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_luks_unlock_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  char* OUT_cleartext_device;
  dbus_g_proxy_end_call (proxy, call, &error, DBUS_TYPE_G_OBJECT_PATH, &OUT_cleartext_device, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_luks_unlock_reply)data->cb) (proxy, OUT_cleartext_device, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_luks_unlock_async (DBusGProxy *proxy, const char * IN_passphrase, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_luks_unlock_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "LuksUnlock", org_freedesktop_DeviceKit_Disks_Device_luks_unlock_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_passphrase, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_luks_lock (DBusGProxy *proxy, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "LuksLock", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_luks_lock_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_luks_lock_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_luks_lock_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_luks_lock_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_luks_lock_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "LuksLock", org_freedesktop_DeviceKit_Disks_Device_luks_lock_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase (DBusGProxy *proxy, const char * IN_current_passphrase, const char * IN_new_passphrase, GError **error)

{
  return dbus_g_proxy_call (proxy, "LuksChangePassphrase", error, G_TYPE_STRING, IN_current_passphrase, G_TYPE_STRING, IN_new_passphrase, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase_async (DBusGProxy *proxy, const char * IN_current_passphrase, const char * IN_new_passphrase, org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "LuksChangePassphrase", org_freedesktop_DeviceKit_Disks_Device_luks_change_passphrase_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_current_passphrase, G_TYPE_STRING, IN_new_passphrase, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "LinuxMdAddComponent", error, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component_async (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "LinuxMdAddComponent", org_freedesktop_DeviceKit_Disks_Device_linux_md_add_component_async_callback, stuff, _dbus_glib_async_data_free, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "LinuxMdRemoveComponent", error, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component_async (DBusGProxy *proxy, const char* IN_component, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "LinuxMdRemoveComponent", org_freedesktop_DeviceKit_Disks_Device_linux_md_remove_component_async_callback, stuff, _dbus_glib_async_data_free, DBUS_TYPE_G_OBJECT_PATH, IN_component, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_linux_md_stop (DBusGProxy *proxy, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "LinuxMdStop", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_linux_md_stop_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_linux_md_stop_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_linux_md_stop_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_linux_md_stop_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_linux_md_stop_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "LinuxMdStop", org_freedesktop_DeviceKit_Disks_Device_linux_md_stop_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling (DBusGProxy *proxy, const char ** IN_options, char ** OUT_cookie, GError **error)

{
  return dbus_g_proxy_call (proxy, "DriveInhibitPolling", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_STRING, OUT_cookie, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling_reply) (DBusGProxy *proxy, char * OUT_cookie, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  char * OUT_cookie;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_STRING, &OUT_cookie, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling_reply)data->cb) (proxy, OUT_cookie, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DriveInhibitPolling", org_freedesktop_DeviceKit_Disks_Device_drive_inhibit_polling_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling (DBusGProxy *proxy, const char * IN_cookie, GError **error)

{
  return dbus_g_proxy_call (proxy, "DriveUninhibitPolling", error, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling_async (DBusGProxy *proxy, const char * IN_cookie, org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DriveUninhibitPolling", org_freedesktop_DeviceKit_Disks_Device_drive_uninhibit_polling_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_cookie, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_poll_media (DBusGProxy *proxy, GError **error)

{
  return dbus_g_proxy_call (proxy, "DrivePollMedia", error, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_poll_media_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_poll_media_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_poll_media_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_poll_media_async (DBusGProxy *proxy, org_freedesktop_DeviceKit_Disks_Device_drive_poll_media_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DrivePollMedia", org_freedesktop_DeviceKit_Disks_Device_drive_poll_media_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_eject (DBusGProxy *proxy, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "DriveEject", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_eject_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_eject_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_eject_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_eject_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_drive_eject_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DriveEject", org_freedesktop_DeviceKit_Disks_Device_drive_eject_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data (DBusGProxy *proxy, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "DriveAtaSmartRefreshData", error, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data_async (DBusGProxy *proxy, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DriveAtaSmartRefreshData", org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_refresh_data_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data (DBusGProxy *proxy, const guint64 IN_since, const guint64 IN_until, const guint64 IN_spacing, GPtrArray** OUT_data, GError **error)

{
  return dbus_g_proxy_call (proxy, "DriveAtaSmartGetHistoricalData", error, G_TYPE_UINT64, IN_since, G_TYPE_UINT64, IN_until, G_TYPE_UINT64, IN_spacing, G_TYPE_INVALID, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_DOUBLE, G_TYPE_UINT64, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT, G_TYPE_UINT64, dbus_g_type_get_collection ("GArray", G_TYPE_UCHAR), G_TYPE_INVALID)), G_TYPE_INVALID)), OUT_data, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data_reply) (DBusGProxy *proxy, GPtrArray *OUT_data, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  GPtrArray* OUT_data;
  dbus_g_proxy_end_call (proxy, call, &error, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT64, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_DOUBLE, G_TYPE_UINT64, dbus_g_type_get_collection ("GPtrArray", dbus_g_type_get_struct ("GValueArray", G_TYPE_UINT, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN, G_TYPE_UINT, G_TYPE_UINT64, dbus_g_type_get_collection ("GArray", G_TYPE_UCHAR), G_TYPE_INVALID)), G_TYPE_INVALID)), &OUT_data, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data_reply)data->cb) (proxy, OUT_data, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data_async (DBusGProxy *proxy, const guint64 IN_since, const guint64 IN_until, const guint64 IN_spacing, org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DriveAtaSmartGetHistoricalData", org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_get_historical_data_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_UINT64, IN_since, G_TYPE_UINT64, IN_until, G_TYPE_UINT64, IN_spacing, G_TYPE_INVALID);
}
static
#ifdef G_HAVE_INLINE
inline
#endif
gboolean
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest (DBusGProxy *proxy, const char * IN_test, const char ** IN_options, GError **error)

{
  return dbus_g_proxy_call (proxy, "DriveAtaSmartInitiateSelftest", error, G_TYPE_STRING, IN_test, G_TYPE_STRV, IN_options, G_TYPE_INVALID, G_TYPE_INVALID);
}

typedef void (*org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest_reply) (DBusGProxy *proxy, GError *error, gpointer userdata);

static void
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest_async_callback (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
{
  DBusGAsyncData *data = (DBusGAsyncData*) user_data;
  GError *error = NULL;
  dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID);
  (*(org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest_reply)data->cb) (proxy, error, data->userdata);
  return;
}

static
#ifdef G_HAVE_INLINE
inline
#endif
DBusGProxyCall*
org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest_async (DBusGProxy *proxy, const char * IN_test, const char ** IN_options, org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest_reply callback, gpointer userdata)

{
  DBusGAsyncData *stuff;
  stuff = g_slice_new (DBusGAsyncData);
  stuff->cb = G_CALLBACK (callback);
  stuff->userdata = userdata;
  return dbus_g_proxy_begin_call (proxy, "DriveAtaSmartInitiateSelftest", org_freedesktop_DeviceKit_Disks_Device_drive_ata_smart_initiate_selftest_async_callback, stuff, _dbus_glib_async_data_free, G_TYPE_STRING, IN_test, G_TYPE_STRV, IN_options, G_TYPE_INVALID);
}
#endif /* defined DBUS_GLIB_CLIENT_WRAPPERS_org_freedesktop_DeviceKit_Disks_Device */

G_END_DECLS
